"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoOpTarget = exports.DIR_TARGET = exports.DEFAULT_TARGET = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

exports.createTargets = createTargets;
exports.createCommonTarget = createCommonTarget;

var _platformPackager;

function _load_platformPackager() {
    return _platformPackager = require("../platformPackager");
}

var _metadata;

function _load_metadata() {
    return _metadata = require("../metadata");
}

var _archive;

function _load_archive() {
    return _archive = require("./archive");
}

var _path = _interopRequireWildcard(require("path"));

var _log;

function _load_log() {
    return _log = require("../util/log");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const archiveTargets = new Set(["zip", "7z", "tar.xz", "tar.lz", "tar.gz", "tar.bz2"]);
const DEFAULT_TARGET = exports.DEFAULT_TARGET = "default";
const DIR_TARGET = exports.DIR_TARGET = "dir";
function createTargets(nameToTarget, rawList, outDir, packager, cleanupTasks) {
    const result = [];
    const mapper = (name, factory) => {
        let target = nameToTarget.get(name);
        if (target == null) {
            target = factory(outDir);
            nameToTarget.set(name, target);
        }
        result.push(target);
    };
    const targets = normalizeTargets(rawList == null || rawList.length === 0 ? packager.platformSpecificBuildOptions.target : rawList);
    packager.createTargets(targets == null ? [DEFAULT_TARGET] : targets, mapper, cleanupTasks);
    return result;
}
function normalizeTargets(targets) {
    if (targets == null) {
        return null;
    } else {
        return (Array.isArray(targets) ? targets : [targets]).map(it => it.toLowerCase().trim());
    }
}
function createCommonTarget(target, outDir, packager) {
    if (archiveTargets.has(target)) {
        return new ArchiveTarget(target, outDir, packager);
    } else if (target === "dir") {
        return new NoOpTarget("dir");
    } else {
        throw new Error(`Unknown target: ${ target }`);
    }
}
class NoOpTarget extends (_platformPackager || _load_platformPackager()).Target {
    build(appOutDir, arch) {
        // no build

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {})();
    }
}
exports.NoOpTarget = NoOpTarget;
class ArchiveTarget extends (_platformPackager || _load_platformPackager()).Target {
    constructor(name, outDir, packager) {
        super(name);
        this.outDir = outDir;
        this.packager = packager;
    }
    build(appOutDir, arch) {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const packager = _this.packager;
            const isMac = packager.platform === (_metadata || _load_metadata()).Platform.MAC;
            const outDir = _this.outDir;
            const format = _this.name;
            (0, (_log || _load_log()).log)(`Building ${ isMac ? "macOS " : "" }${ format }`);
            // we use app name here - see https://github.com/electron-userland/electron-builder/pull/204
            const outFile = function () {
                switch (packager.platform) {
                    case (_metadata || _load_metadata()).Platform.MAC:
                        return _path.join(appOutDir, packager.generateName2(format, "mac", false));
                    case (_metadata || _load_metadata()).Platform.WINDOWS:
                        return _path.join(outDir, packager.generateName(format, arch, false, "win"));
                    case (_metadata || _load_metadata()).Platform.LINUX:
                        return _path.join(outDir, packager.generateName(format, arch, true));
                    default:
                        throw new Error(`Unknown platform: ${ packager.platform }`);
                }
            }();
            const dirToArchive = isMac ? _path.join(appOutDir, `${ packager.appInfo.productFilename }.app`) : appOutDir;
            if (format.startsWith("tar.")) {
                yield (0, (_archive || _load_archive()).tar)(packager.devMetadata.build.compression, format, outFile, dirToArchive, isMac);
            } else {
                yield (0, (_archive || _load_archive()).archive)(packager.devMetadata.build.compression, format, outFile, dirToArchive);
            }
            packager.dispatchArtifactCreated(outFile, isMac ? packager.generateName2(format, "mac", true) : packager.generateName(format, arch, true, packager.platform === (_metadata || _load_metadata()).Platform.WINDOWS ? "win" : null));
        })();
    }
}
//# sourceMappingURL=targetFactory.js.map