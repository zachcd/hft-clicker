"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TmpDir = undefined;

var _os;

function _load_os() {
    return _os = require("os");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _util;

function _load_util() {
    return _util = require("./util");
}

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = _interopRequireDefault(require("bluebird-lst-c"));
}

var _log;

function _load_log() {
    return _log = require("./log");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const mkdtemp = require("fs-extra-p").mkdtemp;
process.setMaxListeners(30);
class TmpDir {
    constructor() {
        this.tmpFileCounter = 0;
    }
    getTempFile(suffix) {
        if (this.tempDirectoryPromise == null) {
            let promise;
            if (mkdtemp == null) {
                const dir = _path.join((0, (_os || _load_os()).tmpdir)(), (0, (_util || _load_util()).getTempName)("electron-builder"));
                promise = (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(dir, { mode: 448 }).thenReturn(dir);
            } else {
                promise = mkdtemp(`${ _path.join(process.env.TEST_DIR || (0, (_os || _load_os()).tmpdir)(), "electron-builder") }-`);
            }
            this.tempDirectoryPromise = promise.then(dir => {
                this.dir = dir;
                const cleanup = () => {
                    if (this.dir == null) {
                        return;
                    }
                    this.dir = null;
                    try {
                        (0, (_fsExtraP || _load_fsExtraP()).removeSync)(dir);
                    } catch (e) {
                        if (e.code !== "EPERM") {
                            (0, (_log || _load_log()).warn)(`Cannot delete temporary dir "${ dir }": ${ (e.stack || e).toString() }`);
                        }
                    }
                };
                process.on("exit", cleanup);
                process.on("uncaughtException", cleanup);
                process.on("SIGINT", cleanup);
                return dir;
            });
        }
        return this.tempDirectoryPromise.then(it => _path.join(it, `t-${ process.pid.toString(16) }-${ (this.tmpFileCounter++).toString(16) }${ suffix.startsWith(".") ? suffix : `-${ suffix }` }`));
    }
    cleanup() {
        const dir = this.dir;
        if (dir == null) {
            return (_bluebirdLstC || _load_bluebirdLstC()).default.resolve();
        }
        this.dir = null;
        return (0, (_fsExtraP || _load_fsExtraP()).remove)(dir).catch(e => {
            if (e.code === "EPERM") {
                this.dir = dir;
            } else {
                (0, (_log || _load_log()).warn)(`Cannot delete temporary dir "${ dir }": ${ (e.stack || e).toString() }`);
            }
        });
    }
}
exports.TmpDir = TmpDir; //# sourceMappingURL=tmp.js.map